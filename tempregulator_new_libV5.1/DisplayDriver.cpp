#include "DisplayDriver.h"                                                        // Подключаем заголовок с определением класса драйвера дисплея
//
#include <Arduino.h>                                                               // Подключаем базовые определения Arduino (SPI, задержки и т.п.)
//
LGFX::LGFX() {                                                                     // Конструктор класса LGFX отвечает за настройку шины, панели и тачскрина
  {                                                                                // Первый блок конфигурирует SPI-шину, по которой работает экран
    auto c = _bus.config();                                                        // Получаем текущую конфигурацию шины LGFX Bus
    c.spi_host   = SPI2_HOST;                                                      // Используем второй SPI-контроллер ESP32
    c.spi_mode   = 0;                                                              // Работаем в режиме SPI Mode0 (CPOL=0, CPHA=0)
    c.freq_write = 40000000;                                                       // Частота записи на дисплей — 40 МГц
    c.freq_read  = 16000000;                                                       // Частота чтения данных — 16 МГц
    c.spi_3wire  = false;                                                          // Отключаем 3-проводной режим, используем классический 4-проводной SPI
    c.use_lock   = true;                                                           // Включаем блокировку шины для потокобезопасного доступа
    c.dma_channel= SPI_DMA_CH_AUTO;                                                // Разрешаем автоматический выбор DMA-канала для ускорения передачи
    c.pin_sclk   = PIN_SCLK;                                                       // Указываем вывод тактового сигнала SPI
    c.pin_mosi   = PIN_MOSI;                                                       // Указываем вывод данных от микроконтроллера к дисплею (MOSI)
    c.pin_miso   = PIN_MISO;                                                       // Указываем вывод данных от дисплея к микроконтроллеру (MISO)
    c.pin_dc     = PIN_TFT_DC;                                                     // Определяем пин выбора команды/данных дисплея (D/C)
    _bus.config(c);                                                                // Передаём обновлённую конфигурацию в объект шины
    _panel.setBus(&_bus);                                                          // Привязываем настроенную шину к панели дисплея
  }                                                                                // Завершение блока настройки шины
  {                                                                                // Второй блок конфигурирует параметры самой TFT-панели
    auto p = _panel.config();                                                      // Получаем текущую конфигурацию панели
    p.pin_cs       = PIN_TFT_CS;                                                   // Пин выбора устройства (CS) для панели
    p.pin_rst      = PIN_TFT_RST;                                                  // Пин аппаратного сброса дисплея
    p.panel_width  = 240;                                                          // Физическая ширина экрана в пикселях
    p.panel_height = 320;                                                          // Физическая высота экрана в пикселях
    p.readable     = true;                                                         // Разрешаем чтение пикселей с экрана
    p.invert       = false;                                                        // Не инвертируем цвета
    p.rgb_order    = false;                                                        // Используем стандартный порядок цветов RGB
    p.dlen_16bit   = false;                                                        // Отправляем данные по 8 бит (не 16)
    p.bus_shared   = true;                                                         // Шина SPI общая с тачскрином, поэтому отмечаем общий доступ
    _panel.config(p);                                                              // Применяем конфигурацию панели
  }                                                                                // Завершение блока настройки панели
  {                                                                                // Третий блок отвечает за конфигурацию контроллера тачскрина
    auto t = _touch.config();                                                      // Получаем текущее состояние конфигурации тача
    t.x_min = 300;                                                                 // Минимальное значение АЦП по X, полученное при калибровке
    t.x_max = 3900;                                                                // Максимальное значение АЦП по X
    t.y_min = 200;                                                                 // Минимальное значение АЦП по Y
    t.y_max = 3900;                                                                // Максимальное значение АЦП по Y
    t.bus_shared = true;                                                           // Тач делит SPI-шину с дисплеем
    t.spi_host = SPI2_HOST;                                                        // Используем тот же SPI-контроллер
    t.freq = 1000000;                                                              // Скорость обмена с тачем — 1 МГц
    t.pin_sclk = PIN_SCLK;                                                         // Общий пин тактового сигнала SPI
    t.pin_mosi = PIN_MOSI;                                                         // Общий пин MOSI для передачи команд
    t.pin_miso = PIN_MISO;                                                         // Общий пин MISO для получения данных тача
    t.pin_cs   = PIN_TOUCH_CS;                                                     // Отдельный пин выбора устройства для тача
    t.pin_int  = -1;                                                               // Не используем отдельный прерывающий пин (отключен)
    _touch.config(t);                                                              // Применяем конфигурацию тачскрина
    _panel.setTouch(&_touch);                                                      // Связываем тач с панелью, чтобы LGFX знала о вводе
  }                                                                                // Завершение блока настройки тача
  setPanel(&_panel);                                                               // Сообщаем базовому классу LGFX, что нужно использовать нашу панель
}                                                                                  // Завершение конструктора LGFX
//
LGFX tft;                                                                          // Создаём глобальный экземпляр дисплея для работы с графикой
//
static lv_color_t buf1[320 * 40];                                                  // Первый буфер LVGL для двойной буферизации (область 320x40 пикселей)
static lv_color_t buf2[320 * 40];                                                  // Второй буфер LVGL для плавной отрисовки
//
static void display_flush_cb(lv_display_t* disp,                                   // Колбэк, который LVGL вызывает для отправки готового блока пикселей на экран
                             const lv_area_t* area,                                // Область экрана, которую нужно обновить
                             uint8_t* px_map) {                                    // Указатель на массив пикселей в формате RGB565
  uint32_t w = static_cast<uint32_t>(area->x2 - area->x1 + 1);                     // Вычисляем ширину области обновления
  uint32_t h = static_cast<uint32_t>(area->y2 - area->y1 + 1);                     // Вычисляем высоту области
  tft.pushImage(area->x1, area->y1, w, h,                                          // Передаём пиксели в драйвер дисплея, начиная с верхнего левого угла области
                reinterpret_cast<const lgfx::rgb565_t*>(px_map));                  // Приводим указатель к типу, ожидаемому библиотекой LovyanGFX
  lv_display_flush_ready(disp);                                                    // Сообщаем LVGL, что обновление завершено
}                                                                                  // Завершение функции колбэка
//
static void touchpad_read_cb(lv_indev_t* indev, lv_indev_data_t* data) {           // Колбэк чтения тачскрина для LVGL
  uint16_t rx, ry;                                                                 // Переменные для сырых значений тачскрина по X и Y
  bool pressed = tft.getTouchRaw(&rx, &ry);                                        // Получаем состояние тача и сырые координаты
  if (g_touch_swap_axes) {                                                         // Если в настройках нужно поменять оси местами
    uint16_t tmp = rx;                                                             // Сохраняем временно значение X
    rx = ry;                                                                       // Переставляем X <- Y
    ry = tmp;                                                                      // Переставляем Y <- X
  }                                                                                // Завершение блока перестановки осей
  data->state = pressed ? LV_INDEV_STATE_PRESSED : LV_INDEV_STATE_RELEASED;        // Устанавливаем состояние указателя для LVGL (нажат или отпущен)
  if (pressed) {                                                                   // Если палец/стилус касается экрана
    const int top_px = 40;                                                         // Верхняя граница активной области интерфейса в пикселях
    const int bot_px = 220;                                                        // Нижняя граница активной области в пикселях
    int16_t y = map_clamped(ry, g_ty_min, g_ty_max, top_px, bot_px);               // Преобразуем сырое значение Y в координату LVGL
    if (y < 0) {                                                                   // Если после преобразования координата ушла ниже нуля
      y = 0;                                                                       // Ограничиваем её нулём
    } else if (y > 239) {                                                          // Если координата превысила максимальную высоту экрана
      y = 239;                                                                     // Ограничиваем максимальным значением
    }                                                                              // Завершение проверки диапазона Y
    int16_t x = map_clamped(rx, g_tx_min, g_tx_max, 0, 319);                       // Преобразуем сырое значение X в координату LVGL
    if (x < 0) {                                                                   // Контролируем выход координаты за пределы экрана
      x = 0;                                                                       // Ограничиваем минимумом
    } else if (x > 319) {                                                          // И максимумом ширины
      x = 319;                                                                     // Возвращаем в допустимый диапазон
    }

    data->point.x = x;                                                             // Сохраняем рассчитанную координату X в структуру LVGL
    data->point.y = y;                                                             // Сохраняем рассчитанную координату Y
  }                                                                                // Завершение обработки нажатия
}                                                                                  // Завершение функции чтения тача
//
lv_display_t* createLvglDisplay() {                                                // Создаём и настраиваем объект дисплея LVGL
  lv_display_t* disp = lv_display_create(320, 240);                                // Создаём дисплей с разрешением 320x240
  lv_display_set_render_mode(disp, LV_DISPLAY_RENDER_MODE_PARTIAL);                // Включаем частичный режим отрисовки (обновляем небольшие области)
  lv_display_set_color_format(disp, LV_COLOR_FORMAT_RGB565);                       // Указываем формат пикселей RGB565
  lv_display_set_flush_cb(disp, display_flush_cb);                                 // Назначаем функцию отправки пикселей на экран
  lv_display_set_buffers(disp, buf1, buf2, sizeof(buf1),                           // Передаём LVGL адреса двух буферов и их размер
                         LV_DISPLAY_RENDER_MODE_PARTIAL);                          // Сообщаем, что работаем в частичном режиме рендеринга
  return disp;                                                                     // Возвращаем готовый объект дисплея
}                                                                                  // Завершение функции создания дисплея
//
void initPointerInput() {                                                          // Инициализируем устройство ввода «указатель» для LVGL
  lv_indev_t* indev = lv_indev_create();                                           // Создаём новое устройство ввода
  lv_indev_set_type(indev, LV_INDEV_TYPE_POINTER);                                 // Указываем, что это указатель (тачскрин/мышь)
  lv_indev_set_read_cb(indev, touchpad_read_cb);                                   // Назначаем функцию, которая будет читать данные тача
}                                                                                  // Завершение функции инициализации указателя

