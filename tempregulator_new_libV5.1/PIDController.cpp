#include "PIDController.h"                                            // Заголовок с определением класса PIDController
//
#include <Arduino.h>                                                   // Используем функции millis() и constrain()
//
void PIDController::setCoeffs(double p, double i, double d) {          // Устанавливаем коэффициенты PID-регулятора
  kp = p;                                                              // Пропорциональный коэффициент
  ki = i;                                                              // Интегральный коэффициент
  kd = d;                                                              // Дифференциальный коэффициент
}                                                                      // Завершение метода setCoeffs
//
void PIDController::setSetpoint(double s) {                            // Устанавливаем требуемую температуру (уставку)
  set = s;                                                             // Запоминаем новое значение уставки
  integral = 0.0;                                                      // Сбрасываем накопленную интегральную составляющую
  prev = 0.0;                                                          // Обнуляем предыдущую ошибку
  last_ms = millis();                                                  // Запоминаем время установки для корректного расчёта dt
}                                                                      // Завершение метода setSetpoint
//
int PIDController::compute(double pv) {                                // Рассчитываем управляющее воздействие по текущему значению процесса
  uint32_t now = millis();                                             // Получаем текущее время в миллисекундах
  double dt_ms = static_cast<double>(now - last_ms);                   // Вычисляем прошедший интервал времени
  if (dt_ms <= 0.0) {                                                  // Защита на случай нулевого/отрицательного интервала
    return 0;                                                          // Возвращаем нейтральное значение
  }                                                                    // Конец проверки dt
  double e = set - pv;                                                 // Ошибка регулирования: разница между уставкой и текущим значением
  integral += e * (dt_ms / 1000.0);                                    // Накопление интегральной составляющей (используем секунды)
  double der = (e - prev) / (dt_ms / 1000.0);                          // Дифференциальная составляющая: скорость изменения ошибки
  prev = e;                                                            // Сохраняем текущую ошибку для следующего шага
  last_ms = now;                                                       // Обновляем отметку времени последнего расчёта
  double out = kp * e + ki * integral + kd * der;                      // Рассчитываем итоговое управляющее воздействие
  return constrain(static_cast<int>(out), 0, 255);                     // Ограничиваем результат диапазоном ШИМ 0-255 и возвращаем его
}                                                                      // Завершение метода compute

